{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport {\n  Database,\n  DatabaseOptions,\n  Key,\n  open,\n  RootDatabase,\n  RootDatabaseOptions,\n} from \"lmdbx\";\n\nexport interface PutOptions {\n  version?: number;\n  ttl?: number; // TTL in milliseconds\n  ifVersion?: number;\n}\n\nexport interface RemoveOptions {\n  quiet?: boolean;\n  ifVersion?: number;\n}\n\ninterface DefaultSerializer<V> {\n  encoder: { encode: (value: V) => Buffer };\n  decoder: { encode: (value: V) => Buffer };\n}\n\ntype DB<V = any, K extends Key = Key> = Database<V, K> & DefaultSerializer<V>;\n\nexport class Store<V = any, K extends Key = Key> extends EventEmitter {\n  protected env: RootDatabase;\n  // Open the TTL bucket directly so it's not patched (and no events are emitted).\n  protected ttlBucket: Database<string, string>;\n  protected dbs: Map<string, DB<any, K>>;\n  protected flushing: boolean = false;\n\n  constructor(name: string, options: RootDatabaseOptions) {\n    super();\n    this.dbs = new Map();\n    this.env = open(name, options);\n    // Open TTL bucket directly (bypassing our patching logic).\n    this.ttlBucket = this.env.openDB(\"ttl\", { cache: true });\n    // this._patch(this.env, \"root\");\n  }\n\n  // Build a TTL key in the format \"exp:bucket:key\"\n  protected ttlKey(exp: number, bucket: string, key: string): string {\n    return `${exp}:${bucket}:${key}`;\n  }\n\n  // Patch a given database to wrap its put and remove methods.\n  protected _patch(db: DB, bucketName: string) {\n    console.log(db);\n    const origPut = db.put.bind(db);\n    const origRemove = db.remove.bind(db);\n    const self = this;\n\n    db.put = (\n      id: K,\n      value: V,\n      verOrOpts?: number | PutOptions,\n      ifVersion?: number\n    ) => {\n      let options: PutOptions = {};\n      if (typeof verOrOpts === \"number\") {\n        options.version = verOrOpts;\n      } else if (typeof verOrOpts === \"object\" && verOrOpts !== null) {\n        options = verOrOpts;\n      }\n\n      const result = origPut(id, value, options.version as number, ifVersion);\n\n      if (options.ttl) {\n        const exp = Date.now() + options.ttl;\n        const ttlEntryKey = self.ttlKey(exp, bucketName, String(id));\n        self.ttlBucket.put(ttlEntryKey, \"\");\n      }\n\n      // const serializer = db as any as DefaultSerializer;\n\n      self.emit(\"change\", {\n        op: \"put\",\n        bucket: bucketName,\n        id,\n        value: db.encoder.encode(value),\n        version: options.version,\n        ttl: options.ttl,\n      });\n\n      return result;\n    };\n\n    db.remove = async (\n      id: K,\n      opts?: number | RemoveOptions\n    ): Promise<boolean> => {\n      let quiet = false;\n      let version: number | undefined;\n      if (typeof opts === \"number\") {\n        version = opts;\n      } else if (typeof opts === \"object\" && opts !== null) {\n        quiet = !!opts.quiet;\n        version = opts.ifVersion;\n      }\n\n      if (!quiet) {\n        const current = db.get(id);\n        self.emit(\"change\", {\n          op: \"remove\",\n          bucket: bucketName,\n          id,\n          value: current,\n          version,\n        });\n      }\n\n      if (typeof opts === \"object\" && opts !== null && opts.quiet) {\n        return origRemove(id, version);\n      }\n      return origRemove(id, opts as any);\n    };\n  }\n\n  // Retrieve or create a sub-database.\n  bucket<TV = any>(name: string, options?: DatabaseOptions): DB<TV, K> {\n    let db = this.dbs.get(name);\n    if (!db) {\n      const opts: DatabaseOptions = { cache: true, ...options };\n      db = this.env.openDB<TV, K>(name, opts) as DB<TV, K>;\n      this.dbs.set(name, db);\n      this._patch(db, name);\n    }\n    return db;\n  }\n\n  // Clean up expired TTL entries in batch.\n  async clean() {\n    if (this.flushing) return;\n    this.flushing = true;\n\n    const keysToDelete: Array<{\n      ttlKey: string;\n      bucketName: string;\n      id: string;\n    }> = [];\n    const now = Date.now().toString();\n\n    for (const key of this.ttlBucket.getKeys({ end: now })) {\n      const parts = key.split(\":\");\n      if (parts.length < 3) continue;\n      const bucketName = parts[1];\n      const id = parts.slice(2).join(\":\");\n      keysToDelete.push({ ttlKey: key, bucketName, id });\n    }\n\n    // Batch removal using a transaction\n    await this.env.transaction(() => {\n      for (const { ttlKey, bucketName, id } of keysToDelete) {\n        const bucket = this.bucket(bucketName);\n        bucket.remove(id as K, { quiet: true });\n        this.ttlBucket.remove(ttlKey);\n      }\n    });\n\n    this.flushing = false;\n  }\n}\n"],"mappings":"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","names":[]}