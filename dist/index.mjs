import{EventEmitter as y}from"events";import{open as h}from"lmdbx";var l=class extends y{constructor(t,o){super();this.flushing=!1;this.dbs=new Map,this.env=h(t,o),this.ttlBucket=this.env.openDB("ttl",{cache:!0})}ttlKey(t,o,e){return`${t}:${o}:${e}`}_patch(t,o){let e=t.put.bind(t),i=t.remove.bind(t),a=this;t.put=(s,n,u,c)=>{let r={};typeof u=="number"?r.version=u:typeof u=="object"&&u!==null&&(r=u);let f=e(s,n,r.version,c);if(r.ttl){let p=Date.now()+r.ttl,b=a.ttlKey(p,o,String(s));a.ttlBucket.put(b,"")}return a.emit("change",{op:"put",bucket:o,id:s,value:t.encoder.encode(n),version:r.version,ttl:r.ttl}),f},t.remove=async(s,n)=>{let u=!1,c;if(typeof n=="number"?c=n:typeof n=="object"&&n!==null&&(u=!!n.quiet,c=n.ifVersion),!u){let r=t.get(s);a.emit("change",{op:"remove",bucket:o,id:s,value:r,version:c})}return typeof n=="object"&&n!==null&&n.quiet?i(s,c):i(s,n)}}bucket(t,o){let e=this.dbs.get(t);if(!e){let i={cache:!0,...o};e=this.env.openDB(t,i),this.dbs.set(t,e),this._patch(e,t)}return e}async clean(){if(this.flushing)return;this.flushing=!0;let t=[],o=Date.now().toString();for(let e of this.ttlBucket.getKeys({end:o})){let i=e.split(":");if(i.length<3)continue;let a=i[1],s=i.slice(2).join(":");t.push({ttlKey:e,bucketName:a,id:s})}await this.env.transaction(()=>{for(let{ttlKey:e,bucketName:i,id:a}of t)this.bucket(i).remove(a,{quiet:!0}),this.ttlBucket.remove(e)}),this.flushing=!1}};export{l as Store};
//# sourceMappingURL=index.mjs.map